<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>常飞</title>
  <subtitle>记录时间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://clfaa.com/"/>
  <updated>2016-04-04T10:51:14.000Z</updated>
  <id>http://clfaa.com/</id>
  
  <author>
    <name>ChangFei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android concurrent（二）—— Future和FutureTask</title>
    <link href="http://clfaa.com/2016/04/04/Android-concurrent%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-Future%E5%92%8CFutureTask/"/>
    <id>http://clfaa.com/2016/04/04/Android-concurrent（二）——-Future和FutureTask/</id>
    <published>2016-04-04T10:49:48.000Z</published>
    <updated>2016-04-04T10:51:14.000Z</updated>
    
    <content type="html">&lt;p&gt;##Future接口&lt;/p&gt;
&lt;h4 id=&quot;官方解释&quot;&gt;&lt;a href=&quot;#官方解释&quot; class=&quot;headerlink&quot; title=&quot;官方解释&quot;&gt;&lt;/a&gt;官方解释&lt;/h4&gt;&lt;p&gt;先让我们看一下，官方对它的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Future represents the result of an asynchronous computation.  Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation.  The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.  Cancellation is performed by the cancel method.  Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&amp;lt;?&amp;gt; and return null as a result of the underlying task.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个Future代表了一个异步计算的结果。 它提供了可以坚持计算是否完成、等待计算完成、检索计算结果的方法。&lt;/li&gt;
&lt;li&gt;get方法获得计算结果的唯一方法，如果计算没有完成，此方法会堵塞直到计算完成。&lt;/li&gt;
&lt;li&gt;cancel方法可以用来取消这次计算。一个已完成的计算是不能被取消的。&lt;/li&gt;
&lt;li&gt;isDone和isCancelled方法可以查询计算是否正常完成还是被取消掉了。&lt;/li&gt;
&lt;li&gt;如果我们不想知道此异步计算的结果，只是想随时取消这次计算，可以通过声明Future&amp;lt;?&amp;gt;并将get的返回值设为null。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####源码分析&lt;br&gt;    public interface Future&lt;v&gt; {&lt;br&gt;        //取消方法&lt;br&gt;        boolean cancel(boolean mayInterruptIfRunning);&lt;br&gt;        //计算是否被取消：如果计算在正常结束前被取消了，则返回true&lt;br&gt;        boolean isCancelled();&lt;br&gt;        //计算是否完成:不管是正常取消、异常结束、还是被取消了，都返回true&lt;br&gt;        boolean isDone();&lt;br&gt;        //检索返回结果，如果计算未完成，则等待任务完成。&lt;br&gt;        V get() throws InterruptedException, ExecutionException;&lt;br&gt;        //和get()方法类似，我们可以通过参数timout和unit指定等待的时间上限，如果时间结束了，计算还未完成，就会抛出TimeOutException异常&lt;br&gt;        V get(long timeout, TimeUnit unit)&lt;br&gt;            throws InterruptedException, ExecutionException, TimeoutException;&lt;br&gt;    }&lt;br&gt;V是实际计算结果的类型，也就是get()方法返回的类型。在其中，一共五个方法。&lt;br&gt;&lt;strong&gt;两个状态查询方法(isCancelled和isDone方法), 一个取消计算方法(cancel)，两个检索结果方法(get()和get(long,TimeUnit))方法。&lt;/strong&gt;&lt;br&gt;对于已经结束任务、已经取消过的任务、不能被取消的任务，调用cancel会失败并返回false; 如果任务还未开始，调用cancel后，任务将不会在被执行，并返回true; 如果任务正在进行中，参数mayInterruptIfRunning为true,则中断执行此任务的线程，false，任务则继续执行，直到完毕。&lt;/v&gt;&lt;/p&gt;
&lt;p&gt;总结：到这儿，Future之所以被设计的原因已经很明了了，其实就是帮助我们可以自由的控制异步任务：可以通过它来查询异步任务的执行状态，取消任务，也可以获得正常的结果。&lt;br&gt;下面我们来看看FutureTask，Future接口的实际实现类。&lt;/p&gt;
&lt;p&gt;##Future的实现：FutureTask&lt;br&gt;其实FutureTask并非直接实现自Future接口，而是RunnableFuture接口，RunnableFutrue是什么，看下源码，便一目了然。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; {
    void run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，FutureTask同时实现了Runnable和Future两大知名接口，所以FutureTask可以提交给&lt;a href=&quot;http://clfaa.com/2016/04/04/Android-concurrent（一）——-Executor接口/&quot;&gt;Executor&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;#####FutureTask源码分析&lt;br&gt;首先我们来看一下FutureTask的两个个构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//构造函数一
public FutureTask(Callable&amp;lt;V&amp;gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}
//构造函数二
public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;源码显示，不管我们使用哪个构造函数，其内部都是把将传入的参数保存为callable，并且把状态置为NEW。FutureTask一共声明了7个状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NEW&lt;/td&gt;
&lt;td&gt;初始状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMPLETING&lt;/td&gt;
&lt;td&gt;进行中状态，表示正在设置结果。很短暂的一个状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NORMAL&lt;/td&gt;
&lt;td&gt;正常结束的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXCEPTIONAL&lt;/td&gt;
&lt;td&gt;异常状态，任务异常结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CANCELLED&lt;/td&gt;
&lt;td&gt;任务成功被取消的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERRUPTING&lt;/td&gt;
&lt;td&gt;很短暂的状态，当在NEW状态下，调用了cancel(true),则状态就会转换为INTERRUPTING，直到执行了Thread#interrupt()方法，状态转换为INTERRUPTED&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERRUPTED&lt;/td&gt;
&lt;td&gt;任务被中断后的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;####run()方法讲解&lt;br&gt;FatureTask被创建后，下面进入run()方法，&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (state != NEW ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      !UNSAFE.compareAndSwapObject(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, runnerOffset,&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, Thread.currentThread()))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Callable&amp;lt;V&amp;gt; c = callable;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (c != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state == NEW) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           V result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; ran;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result = c.call();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ran = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               result = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               ran = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               setException(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ran)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               set(result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runner = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt;= INTERRUPTING)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            handlePossibleCancellationInterrupt(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在run()方法中，先进行状态检查，检查是否处于NEW状态，然后将执行线程的引用保存在runner的变量。FurtureTask的runner变量用来引用任务执行所在的线程。然后执行Callable的call的方法，进行任务执行。接下来会出现两种情况：&lt;br&gt;&lt;strong&gt;情况一：&lt;/strong&gt; 如果执行顺利完成，则调用set(result)的方法。在set()方法中，先将状态置为COMPLETING，然后将执行结果保存到全局变量outcome中，然后将状态置为NORMAL。然后调动finishCompletion()方法，通知所有等待结果的线程，并调用done()(在这里是个空方法)&lt;br&gt;&lt;strong&gt;情况二：&lt;/strong&gt;如果执行出现了异常。则执行setException()方法。在setException()方法中，操作基本和set()方法一样，只是outcome保存的是Throwable。&lt;/p&gt;
&lt;p&gt;全局outcome变量：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Object outcome;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;####流程图&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;st=&amp;gt;start: Start&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cond1=&amp;gt;condition: 处于NEW&amp;amp;&amp;amp;runner赋值成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;op1=&amp;gt;operation: 执行任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cond2=&amp;gt;condition: 发生异常?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;op2=&amp;gt;operation: 设置结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;op3=&amp;gt;operation: 设置异常结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;op4=&amp;gt;operation: runner设置为null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e=&amp;gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;op=&amp;gt;operation: My Operation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;st-&amp;gt;cond1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cond1(yes)-&amp;gt;op1-&amp;gt;cond2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cond1(no)-&amp;gt;e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cond2(yes)-&amp;gt;op2-&amp;gt;op4-&amp;gt;e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cond2(no)-&amp;gt;op3-&amp;gt;op4-&amp;gt;e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;run()方法的大致操作流程就是这样的。&lt;/p&gt;
&lt;p&gt;####FutureTask对Future接口界面的实现&lt;/p&gt;
&lt;p&gt;#####isCanceled()和isDone()&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isCancelled&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; state &amp;gt;= CANCELLED;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isDone&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; state != NEW;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当前任务的状态保存在全局变量state中。这里检查是否取消和是否完成，只要检查一下state的值即可。&lt;/p&gt;
&lt;p&gt;#####cancel(boolean)方法&lt;br&gt;下面，我们看一下cancel方法的实现&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; mayInterruptIfRunning)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(state == NEW &amp;amp;&amp;amp; UNSAFE.compareAndSwapInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, stateOffset, NEW,mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;    &lt;span class=&quot;comment&quot;&gt;// in case call to interrupt throws exception&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mayInterruptIfRunning) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Thread t = runner;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    t.interrupt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// final state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                UNSAFE.putOrderedInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, stateOffset, INTERRUPTED);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        finishCompletion();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;cancel方面会直接检测当前状态是否是NEW,如果不是，说明任务已经完成或取消或中断，所以直接返回。当符合条件后，检查mayInterruptIfRunning的值，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果mayInterruptIfRunning == false,则直接将状态设置为CANCELLED，并且调用finishCompletion()方法，通知正在等待结果的线程。&lt;/li&gt;
&lt;li&gt;如果mayInterruptIfRunning == true,则暂时将状态设置为INTERRUPTING，然后试着中断线程，完成后将状态设置为INTERRUPTED，最后调用finishCompletion()方法，通知正在等待结果的线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#####get()方法的实现&lt;br&gt;get()方法首先还是进行状态监测，如果现在正处于NEW和COMPLETING状态，则会调用awaitDone()，直到状态的转变为其他状态，然后调用report()方法，在report()方法中，首先监测状态：如果是NORMAL状态，直接返回保存在outCome中的结果；如果是CANCELLED、INTERRUPTING、INTERRUPTED状态，则抛出CancellationException()；如果处于其他状态则抛出ExecutionException（比如调用了get(true,atime)方法，时间到期后状态可能还处于NEW状态）。&lt;br&gt;&lt;strong&gt;源码&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; CancellationException &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@inheritDoc&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (s &amp;lt;= COMPLETING)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s = awaitDone(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; report(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Returns result or throws exception for completed task.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; s completed state value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;report&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ExecutionException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Object x = outcome;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (s == NORMAL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (V)x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt;= CANCELLED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CancellationException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExecutionException((Throwable)x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中awaitDone(boolean timed, long nanos)方法用于等待任务完成、任务中断或时间到期。在此方法体中，显示将这次等待保存到全局变量watiers中，用于记录所有调用了get()渴望获得结果并堵塞的Thread，然后不停的循环查询state。直到时间到期或执行完成，则将循环中断，返回转变后的state供report()方法使用。&lt;/p&gt;
&lt;p&gt;注：在FutureTask的的源码中，使用了&lt;a href=&quot;http://www.docjar.com/html/api/sun/misc/Unsafe.java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sun.misc.Unsafe&lt;/a&gt;进行状态的赋值等操作，这是一个强大的对内存进行操作的类，可以通过它绕过jdk的很多限制。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##Future接口&lt;/p&gt;
&lt;h4 id=&quot;官方解释&quot;&gt;&lt;a href=&quot;#官方解释&quot; class=&quot;headerlink&quot; title=&quot;官方解释&quot;&gt;&lt;/a&gt;官方解释&lt;/h4&gt;&lt;p&gt;先让我们看一下，官方对它的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Futur
    
    </summary>
    
    
      <category term="Android" scheme="http://clfaa.com/tags/Android/"/>
    
      <category term="Future" scheme="http://clfaa.com/tags/Future/"/>
    
      <category term="Concurrent" scheme="http://clfaa.com/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Android concurrent（一）—— Executor接口</title>
    <link href="http://clfaa.com/2016/04/04/Android-concurrent%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-Executor%E6%8E%A5%E5%8F%A3/"/>
    <id>http://clfaa.com/2016/04/04/Android-concurrent（一）——-Executor接口/</id>
    <published>2016-04-03T18:30:45.000Z</published>
    <updated>2016-04-04T11:08:02.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;设计理念——为何而存在&quot;&gt;&lt;a href=&quot;#设计理念——为何而存在&quot; class=&quot;headerlink&quot; title=&quot;设计理念——为何而存在&quot;&gt;&lt;/a&gt;设计理念——为何而存在&lt;/h4&gt;&lt;p&gt;先来一发源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是这么短。那么这么短的一个接口存在的意义是什么呢？&lt;br&gt;下面就来分析一下。&lt;br&gt;&amp;lt;!–more&lt;br&gt;当我们想创建并执行一个线程的时候，通常是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Thread(new(RunnableTask())).start()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是短！平！快！。这样不是很好吗？但是使用这种方式，我们无法控制程序中线程的数量，创建过多的线程会带来性能问题。我们需要一种方式控制线程的数量，有时我们还希望控制各个任务之间调度关系。Executor接口正式为解决这个问题而来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Executor接口官方介绍：An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc.  An Executor is normally used instead of explicitly creating threads. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思：Executor是用来提交Runnable的。它可以将Runnable的递交、使用的细节、调度与执行解耦。用来代替直接创建Thread的方式。&lt;/p&gt;
&lt;p&gt;不容易理解？莫关系！下面通过一个实际应用来解释这段话。&lt;/p&gt;
&lt;p&gt;比如，你想保证任务的顺序执行（每个时刻只有一个Runnable在执行，只有上一个Runnable执行完毕之后才会执行下一个Runnable）并且为每一个Runnable创建一个新的Thread。我们可以这样做:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //SerialExecutor提供调度功能，将用户提交的Runnable保存到一个队列里面，然后顺序执行
  class SerialExecutor implements Executor {
    //队列，用来存放提交进来的Runnable
    final Queue&amp;lt;Runnable&amp;gt; tasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
    //提交进来的Runnable实际执行的位置。
    final Executor executor;
    //当前正在执行的Runnable
    Runnable active;
    SerialExecutor(Executor executor) {
      this.executor = executor;
    }
    public synchronized void execute(final Runnable r) {
      //将Runnable包装，并添加到队里中。
      tasks.offer(new Runnable() {
        public void run() {
          try {
            r.run();
          } finally {
            //执行完毕后，会自动调用队里中的下一个Runnable
            scheduleNext();
          }
        }
      });
      if (active == null) {
        //首次调度
        scheduleNext();
      }
    }
    protected synchronized void scheduleNext() {
      if ((active = tasks.poll()) != null) {
        executor.execute(active);
      }
    }
  }}

//ThreadPerTaskExecutor是Runnable的实际执行的地方。为每一个Runnable创建一个Thread。
class ThreadPerTaskExecutor implements Executor {
 public void execute(Runnable r) {
     new Thread(r).start();
 }
}}

//执行：只有任务1执行完毕后才会执行任务2
Executor executor = new SerialExecutor(new ThreadPerTaskExecutor());
executor.execute(new Runnable(){
    public void run() {
         //任务1...     
    }
});
executor.execute(new Runnable(){
    public void run() {
         //任务2...     
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，SerialExecutor用于Runnable的调度，它将Runnable进行简单的包装，并保存到队里中。经过包装后，不仅会执行原始提交Runnable的代码，并且会执行结束后调用队列中的下一个Runnable。就这样,SerialExecutor实现了Runnable的顺序执行。而ThreadPerTaskExecutor类则是用来控制Runnable执行细节的地方，在这里，我们简单的为每个Runnable创建了新的Thread，在实际应用中，你可以使用线程池来复用Thread。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;Executor被创造的原因：将任务的执行、任务的调度、任务的执行细节进行解耦。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任务是如何调度的，你是想一个个的顺序执行，还是想多个任务一起并发并能自由的控制并发数量上线，都可以通过自己实现Executor接口进行定制。你只需要将任务通过Executor#execute(Runnable)方法提交进来就可以了，具体的调度方案，Runnable不需要关注。这样就实现了任务执行和调度的解耦。&lt;/li&gt;
&lt;li&gt;对于任务的执行细节，你是想为每个任务都创建新的线程，还是想复用已有的线程，也可以通过实现Executor接口进行定制。同样，你只需要将任务通过Executor#execute(Runnable)方法提交进来就可以了，具体的执行细节，Runnable不需要关注。这样就实现了任务执行和执行细节的解耦。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;设计模式的使用：中介者模式&quot;&gt;&lt;a href=&quot;#设计模式的使用：中介者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式的使用：中介者模式&quot;&gt;&lt;/a&gt;设计模式的使用：中介者模式&lt;/h4&gt;&lt;p&gt;在这里，使用了设计模式中的&lt;strong&gt;中介者模式&lt;/strong&gt;，下面是中介者模式的定义和UML类图。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中介者模式（Mediator Pattern）：定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抽象中介者（Mediator）角色：抽象中介者角色定义统一的接口用于各同事角色之间的通信。&lt;/li&gt;
&lt;li&gt;具体中介者（Concrete Mediator）角色：具体中介者角色通过协调各同事角色实现协作行为。为此它要知道并引用各个同事角色。&lt;/li&gt;
&lt;li&gt;同事（Colleague）角色：每一个同事角色都知道对应的具体中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。——《设计模式》&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;UML类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Mediator_Pattern.jpg&quot; alt=&quot;Mediator_Pattern.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中Executor就是一个抽象中介者角色，Executor的具体实现就是一个具体中介者角色，每个Runnable就相当于同事角色，Executor的execute(Runnable…)方法即是各个Runnable之间通信的接口，每个Runnable都被提交到Executor的具体实现类中，由Executor的具体实现类来协调各Runnable之间的实现协作行为。–&amp;gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;设计理念——为何而存在&quot;&gt;&lt;a href=&quot;#设计理念——为何而存在&quot; class=&quot;headerlink&quot; title=&quot;设计理念——为何而存在&quot;&gt;&lt;/a&gt;设计理念——为何而存在&lt;/h4&gt;&lt;p&gt;先来一发源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public inte
    
    </summary>
    
    
      <category term="Android" scheme="http://clfaa.com/tags/Android/"/>
    
      <category term="Concurrent" scheme="http://clfaa.com/tags/Concurrent/"/>
    
      <category term="Executor" scheme="http://clfaa.com/tags/Executor/"/>
    
  </entry>
  
  <entry>
    <title>网络编程之AsyncTask使用总结</title>
    <link href="http://clfaa.com/2016/03/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BAsyncTask%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://clfaa.com/2016/03/25/网络编程之AsyncTask使用总结/</id>
    <published>2016-03-25T14:18:06.000Z</published>
    <updated>2016-03-25T14:21:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;官方概述&quot;&gt;&lt;a href=&quot;#官方概述&quot; class=&quot;headerlink&quot; title=&quot;官方概述&quot;&gt;&lt;/a&gt;官方概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.&lt;/p&gt;
&lt;p&gt;AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask.&lt;/p&gt;
&lt;p&gt;An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：&lt;em&gt;AsyncTask&lt;/em&gt;可以恰当方便的操作UI线程。它可以执行后台任务，并把任务结果发布到UI线程，而且不需要手动的操作&lt;em&gt;thread&lt;/em&gt;和&lt;em&gt;handler&lt;/em&gt;。&lt;br&gt;AsyncTask并不是一个通常的线程框架，而是为Thread和Handler设计的帮助类。AsyncTask最适合用于耗时较短（最多几秒钟）的操作。如果需要在线程中执行长时间的操作，强烈推荐使用&lt;em&gt;java.util.concurrent&lt;/em&gt;包提供的API,比如&lt;em&gt;Executor&lt;/em&gt;,&lt;em&gt;TreadPoolExecutor&lt;/em&gt;和&lt;em&gt;FutureTask&lt;/em&gt;。&lt;br&gt;一个&lt;em&gt;AsyncTask&lt;/em&gt;可以把操作的执行过程放到子线程中执行，把执行结果发布到UI线程。定义一个&lt;em&gt;AsyncTask&lt;/em&gt;需要指定&lt;em&gt;Params&lt;/em&gt;,&lt;em&gt;Progress&lt;/em&gt;,&lt;em&gt;Result&lt;/em&gt;三个泛型的类型，在执行过程中将调用&lt;em&gt;onPreExecute&lt;/em&gt;,&lt;em&gt;doInBackground&lt;/em&gt;, &lt;em&gt;onProgressUpdate&lt;/em&gt; 和 &lt;em&gt;onPostExecute&lt;/em&gt;四个方法。&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;AsyncTask为抽象类,使用前必须先定义一个它的子类，实现&lt;em&gt;doInBackground()&lt;/em&gt;方法，为Params,Progress,Result指定确切的参数。&lt;/p&gt;
&lt;h5 id=&quot;实现说明&quot;&gt;&lt;a href=&quot;#实现说明&quot; class=&quot;headerlink&quot; title=&quot;实现说明&quot;&gt;&lt;/a&gt;实现说明&lt;/h5&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Params&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;任务所需参数的类型，变长参数；在调用任务执行方法execute()时，作为execute的参数使用。若不使用，指定为Void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Progress&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;说明任务执行的进度的类型，如Integer等;若不使用，指定为Void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Result&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;任务完成后返回的结果的类型,若不使用，指定为Void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;方法调用顺序&quot;&gt;&lt;a href=&quot;#方法调用顺序&quot; class=&quot;headerlink&quot; title=&quot;方法调用顺序&quot;&gt;&lt;/a&gt;方法调用顺序&lt;/h5&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;顺序&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;方法&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;运行位置&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;必须实现&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.Task执行前&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;onPreExecute()&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;UI Thread&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;否&lt;/td&gt;
&lt;td&gt;在Task执行前调用（即，doInBackground()法前），可用于做一些任务执行前的操作，如显示一个ProgressDialog说明进度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.Task执行中&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;doInBackground(Params…)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;background Thread&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;td&gt;用于执行Task,在此方法中，可以调用publishProgress(Progress…) 发布Task实时进度信息，在onProgressUpdate(Progress…)接收到发布的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.Task执行中&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;onProgressUpdate(Progress…)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;UI Thread&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;否&lt;/td&gt;
&lt;td&gt;接收publishProgress(Progress…)发布的Task进度信息，可以在这里更新显示进度的界面，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.Task执行完成后&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;onPostExecute(Result)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;UI Thread&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;否&lt;/td&gt;
&lt;td&gt;用于接收Task执行的结果，在UI thread中执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;官方提供的示例&quot;&gt;&lt;a href=&quot;#官方提供的示例&quot; class=&quot;headerlink&quot; title=&quot;官方提供的示例&quot;&gt;&lt;/a&gt;官方提供的示例&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//定义一个AysncTask类的子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DownloadFilesTask&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncTask&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;URL&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Long&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Long &lt;span class=&quot;title&quot;&gt;doInBackground&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(URL... urls)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count = urls.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; totalSize = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             totalSize += Downloader.downloadFile(urls[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             publishProgress((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) ((i / (&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;) count) * &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;comment&quot;&gt;// Escape early if cancel() is called&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isCancelled()) &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; totalSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onProgressUpdate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer... progress)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         setProgressPercent(progress[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onPostExecute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Long result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         showDialog(&lt;span class=&quot;string&quot;&gt;&quot;Downloaded &quot;&lt;/span&gt; + result + &lt;span class=&quot;string&quot;&gt;&quot; bytes&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//调用方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DownloadFilesTask().execute(url1, url2, url3);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个示例中，定义了一个AsyncTask的子类DownloadFilesTask，其中URL对应Params,Integer表示进度Progress,Long为执行结果Result的类型。&lt;br&gt;doInBackground()方法体的代码将在子线程中执行。&lt;br&gt;publishProgress()方法用来发布任务执行进度情况，此方法被调用后，会唤起在UI线程中执行的onProgresssUpdate()方法，并接收publishProgress()发布的信息，我们可以根据这些信息更新我们的view等。&lt;br&gt;当后台任务执行完成后，onPostExecute()方法会被调用，此方法也是在UI线程中执行。&lt;/p&gt;
&lt;h5 id=&quot;使用注意事项&quot;&gt;&lt;a href=&quot;#使用注意事项&quot; class=&quot;headerlink&quot; title=&quot;使用注意事项&quot;&gt;&lt;/a&gt;使用注意事项&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;AsyncTask类必须加载在UI thread。（Android系统会自动完成，不需要管）&lt;/li&gt;
&lt;li&gt;AsyncTask类的必须在UI thread中实例化。（因为AsyncTask中的Handler必须属于UI thread,AsyncTask才能和UI thread中执行）&lt;/li&gt;
&lt;li&gt;execute(Params…) 必须在UI thread中被调用。&lt;/li&gt;
&lt;li&gt;不要手动调用 onPreExecute(), onPostExecute(Result), doInBackground(Params…), onProgressUpdate(Progress…) 方法，这些方法的调用由AsyncTask自定完成&lt;/li&gt;
&lt;li&gt;一个AsyncTask的实例只能执行一次，即，execute(Params…)方法只能调用一次&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;取消Task&quot;&gt;&lt;a href=&quot;#取消Task&quot; class=&quot;headerlink&quot; title=&quot;取消Task&quot;&gt;&lt;/a&gt;取消Task&lt;/h3&gt;&lt;p&gt;官方说明:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A task can be cancelled at any time by invoking &lt;strong&gt;cancel(boolean)&lt;/strong&gt;. Invoking this method will cause subsequent calls to &lt;strong&gt;isCancelled()&lt;/strong&gt; to return true. After invoking this method, &lt;strong&gt;onCancelled(Object)&lt;/strong&gt;, instead of &lt;strong&gt;onPostExecute(Object) &lt;/strong&gt;will be invoked after &lt;strong&gt;doInBackground(Object[])&lt;/strong&gt; returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of &lt;strong&gt;isCancelled()&lt;/strong&gt; periodically from &lt;strong&gt;doInBackground(Object[])&lt;/strong&gt;， if possible (inside a loop for instance.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：你可以在任何时候通过调用&lt;strong&gt;cancel(boolean)&lt;/strong&gt;取消Task，&lt;strong&gt;cancel(boolean)&lt;/strong&gt;方法被调用后，调用&lt;strong&gt;isCancelled()&lt;/strong&gt;方法将返回&lt;strong&gt;True&lt;/strong&gt;,并且在&lt;strong&gt;doInBackground(Object[])&lt;/strong&gt;返回后，不在调用&lt;strong&gt;onPostExecute(Object) &lt;/strong&gt;，而是调用 &lt;strong&gt;onCancelled(Object)&lt;/strong&gt;。为了保证Task尽可能快的被取消掉，你应该在&lt;strong&gt;doInBackground(Object[])&lt;/strong&gt;方法中不停的查询 &lt;strong&gt;isCancelled()&lt;/strong&gt; 的返回值，最好在方法中实现一个循环。&lt;/p&gt;
&lt;p&gt;我们来看一下&lt;strong&gt;cancel(boolean)&lt;/strong&gt;的源码&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AtomicBoolean mCancelled = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AtomicBoolean();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; mayInterruptIfRunning)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   mCancelled.set(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mFuture.cancel(mayInterruptIfRunning);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cancle(boolean)&lt;/strong&gt;只是将mCancelled的值置为true，而任是真正被取消的操作，要在doInBackground(Params)方法中通过查询mCancelled的值为true时才进行取消。&lt;/p&gt;
&lt;p&gt;官方指出最好在&lt;strong&gt;doInBackground(Object[])&lt;/strong&gt;中实现一个循环，用来保证尽快收到任务取消的信息。代码如下:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Void &lt;span class=&quot;title&quot;&gt;doInBackground&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer... params)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (isCancelled())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h5&gt;&lt;p&gt;但是有时候，我们无法使用循环，比如读取文件、请求网络等。如果你调用了&lt;strong&gt;cancel(false)&lt;/strong&gt;，任务会继续执行，直到任务完成，但&lt;strong&gt;onPostExecute()&lt;/strong&gt;将不被会被调用，而是调用&lt;strong&gt;onCancel()&lt;/strong&gt;。但我们的初衷是想让任务马上停止，而不是继续执行到完成，所以我们的程序做了无用功。如果使用cancel(true) 方法，即，参数mayInterruptIfRunning被置为true,那将提前中断我们的任务，但是如果我们的方法是不可中断的，例如BitmapFactory.decodeStream()方法，那么任务将继续执行。你可以过早的关闭这个流（stream）并捕获它抛出的异常，但这并不是通过调用&lt;strong&gt;cancel(true)&lt;/strong&gt;完成的，因此&lt;strong&gt;cancel(true)&lt;/strong&gt;就变的没有意义了。&lt;/p&gt;
&lt;h3 id=&quot;执行顺序：多个AsyncTask实例之间的执行顺序&quot;&gt;&lt;a href=&quot;#执行顺序：多个AsyncTask实例之间的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;执行顺序：多个AsyncTask实例之间的执行顺序&quot;&gt;&lt;/a&gt;执行顺序：多个AsyncTask实例之间的执行顺序&lt;/h3&gt;&lt;p&gt;在Android 1.6之前AsyncTask是顺序执行的，在一个App中，只有前一个Task执行完成后, 下一个AsyncTask才能执行。&lt;br&gt;在Android 1.6-Android2.3中，由一个线程池来管理多个线程，同一时刻，可以有多个Task在执行。&lt;br&gt;从Android3.0开始，Google为了避免并行执行给多个应用带来的错误，有改为了顺序执行。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;执行顺序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Android 1.6之前&lt;/td&gt;
&lt;td&gt;顺序执行：&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 1.6-Android2.3&lt;/td&gt;
&lt;td&gt;并行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 3.0-至今&lt;/td&gt;
&lt;td&gt;顺序执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当然我们可以通过调用 executeOnExecutor(java.util.concurrent.Executor, Params…）而非execute(Params..)方法来完成并行执行。&lt;br&gt;比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;可能发生的内存泄露-Memory-leaks&quot;&gt;&lt;a href=&quot;#可能发生的内存泄露-Memory-leaks&quot; class=&quot;headerlink&quot; title=&quot;可能发生的内存泄露(Memory leaks)&quot;&gt;&lt;/a&gt;可能发生的内存泄露(Memory leaks)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;我们可能有这样的错觉：当Activity被销毁时，其创建的AsyncTask也同样会被销毁——其实，并不然！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当Activity销毁后，AsyncTask继续执行直到完成。如果你在Activity#onDestroy()中调用了 cancel(boolean)方法，它会继续执行onCancelled(Result result)方法，如果你没有调用 cancel(boolean)方法，它会执行onPostExecute(Result) 方法。&lt;/p&gt;
&lt;p&gt;假如在Activity被销毁前，我们没有调用AsyncTask#cancel(boolean)方法。这可能引起内存泄露，导致程序崩溃。比如你在onPostExecute(Result) 中对Activity的View进行操作，但是这些View已经随着Activity的销毁不再存在。所以，我们要确保在Activity销毁前，取消掉Task。&lt;/p&gt;
&lt;p&gt;因为异步任务有方法在background Thread 中执行（doInBackground()），并且也有方法在UI线程中执行（比如，onPostExecute()）；在Task运行阶段，它将持有Activity的引用。但是如果Activity已经被销毁，它仍然持有这个的内存的引用。如何在后续的操作中，使用这个已经销毁的Activity的引用，将直接导致程序崩溃。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;官方概述&quot;&gt;&lt;a href=&quot;#官方概述&quot; class=&quot;headerlink&quot; title=&quot;官方概述&quot;&gt;&lt;/a&gt;官方概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;AsyncTask enables proper and easy use of the UI t
    
    </summary>
    
    
      <category term="Android" scheme="http://clfaa.com/tags/Android/"/>
    
      <category term="网络编程" scheme="http://clfaa.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AsyncTask" scheme="http://clfaa.com/tags/AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>自定义Android debug keystore</title>
    <link href="http://clfaa.com/2016/03/21/%E8%87%AA%E5%AE%9A%E4%B9%89keystore/"/>
    <id>http://clfaa.com/2016/03/21/自定义keystore/</id>
    <published>2016-03-21T14:50:57.000Z</published>
    <updated>2016-04-04T04:36:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;为什么替换&quot;&gt;&lt;a href=&quot;#为什么替换&quot; class=&quot;headerlink&quot; title=&quot;为什么替换&quot;&gt;&lt;/a&gt;为什么替换&lt;/h2&gt;&lt;p&gt;Android开发中，在使用第三方的sdk（如，百度地图，微信分享，友盟统计等）提供的功能时通常都要事先申请密钥，在申请密钥时需要填写keystore的数字签名（SHA1）。这样，只有使用此keystore打包生成的apk才能正常的调用这些第三方提供的功能。如果你不想在每次修改相关代码后，都要执行繁琐的验证打包安装等流程，才能测试相应得功能的话，就将此keystore替换默认keystore吧。如果你不想你团队的每一个人都要申请一个自己密钥进行调试的话，就把你的keystore分发给他们，让他们替换了吧。&lt;/p&gt;
&lt;h2 id=&quot;修改keystore信息&quot;&gt;&lt;a href=&quot;#修改keystore信息&quot; class=&quot;headerlink&quot; title=&quot;修改keystore信息&quot;&gt;&lt;/a&gt;修改keystore信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;想要替换默认的keystore，那么你的keystore的密码、别名等信息必须和默认debug.keystore的一样，默认debug.keystore的信息如下：&lt;br&gt;Keystore name: “debug.keystore”&lt;br&gt;Keystore password: “android”&lt;br&gt;Key alias: “androiddebugkey”&lt;br&gt;Key password: “android”&lt;br&gt;CN: “CN=Android Debug,O=Android,C=US”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;重命名.keystore文件名：将自己的.keystore修改名称修改为debug.keystore（可选，只是在输入下面的命令是，将debug.keystore更换为你的keystore文件名）&lt;/li&gt;
&lt;li&gt;修改keystore密码为“android”：键入命令&lt;br&gt;&lt;code&gt;keytool -storepasswd -new android -keystore debug.keystore&lt;/code&gt;&lt;br&gt;按提示输入原密码，修改密码完成&lt;/li&gt;
&lt;li&gt;修改别名为androiddebugkey：&lt;br&gt;&lt;code&gt;keytool -changealias -keystore debug.keystore -alias 原别名 -destalias androiddebugkey&lt;/code&gt;,&lt;br&gt;按提示输入keystore密码、alias 原密码、新密码、再次输入新密码&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;替换IDE的keystore&quot;&gt;&lt;a href=&quot;#替换IDE的keystore&quot; class=&quot;headerlink&quot; title=&quot;替换IDE的keystore&quot;&gt;&lt;/a&gt;替换IDE的keystore&lt;/h2&gt;&lt;h3 id=&quot;Eclipse&quot;&gt;&lt;a href=&quot;#Eclipse&quot; class=&quot;headerlink&quot; title=&quot;Eclipse&quot;&gt;&lt;/a&gt;Eclipse&lt;/h3&gt;&lt;p&gt;依次选择：Window-&amp;gt;Preferences-&amp;gt;Android-&amp;gt;Build-&amp;gt;Custom debug keystore，选择你刚刚修改完成的keystore文件。&lt;br&gt;&lt;img src=&quot;/images/debug_key_eclipse.png&quot; alt=&quot;eclipse截图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Intellij-Idea&quot;&gt;&lt;a href=&quot;#Intellij-Idea&quot; class=&quot;headerlink&quot; title=&quot;Intellij Idea&quot;&gt;&lt;/a&gt;Intellij Idea&lt;/h3&gt;&lt;p&gt;依次选择：Project structure -&amp;gt; Facets -&amp;gt;Packaging -&amp;gt; custom debug keystore，选择你刚刚修改完成的keystore文件。&lt;br&gt;&lt;img src=&quot;/images/debug_key_intellj.png&quot; alt=&quot;intellij idea截图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Android-Studio（不需要进行上面的步骤）&quot;&gt;&lt;a href=&quot;#Android-Studio（不需要进行上面的步骤）&quot; class=&quot;headerlink&quot; title=&quot;Android Studio（不需要进行上面的步骤）&quot;&gt;&lt;/a&gt;Android Studio（不需要进行上面的步骤）&lt;/h3&gt;&lt;p&gt;在项目的build.gradle的中引入如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android {
         //配置keystore签名
        signingConfigs {
            release {
                storeFile file(&amp;quot;xxxxxxxxStore&amp;quot;)
                storePassword &amp;quot;xxxxxxxx&amp;quot;
                keyAlias &amp;quot;timehut team&amp;quot;
                keyPassword &amp;quot;xxxxxxxx&amp;quot;
            }
        }
        buildTypes {
            debug {
                signingConfig signingConfigs.release
            }
            release {
                signingConfig signingConfigs.release
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么替换&quot;&gt;&lt;a href=&quot;#为什么替换&quot; class=&quot;headerlink&quot; title=&quot;为什么替换&quot;&gt;&lt;/a&gt;为什么替换&lt;/h2&gt;&lt;p&gt;Android开发中，在使用第三方的sdk（如，百度地图，微信分享，友盟统计等）提供的功能时通常都要事先申请密钥，在
    
    </summary>
    
    
      <category term="Android" scheme="http://clfaa.com/tags/Android/"/>
    
      <category term="Keystore" scheme="http://clfaa.com/tags/Keystore/"/>
    
      <category term="Debug" scheme="http://clfaa.com/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>在github上创建个人主页</title>
    <link href="http://clfaa.com/2016/03/21/%E5%9C%A8github%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <id>http://clfaa.com/2016/03/21/在github上创建个人主页/</id>
    <published>2016-03-21T13:25:42.000Z</published>
    <updated>2016-03-21T15:22:31.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;每一个github账号都可以创建一个用来存放个人主页，&lt;strong&gt;仓库的名字必须是username/username.github.io&lt;/strong&gt;，创建完成之后就可以使用&lt;strong&gt;username.github.io&lt;/strong&gt;来访问自己的个人主页了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建仓库，生成默认主页&quot;&gt;&lt;a href=&quot;#创建仓库，生成默认主页&quot; class=&quot;headerlink&quot; title=&quot;创建仓库，生成默认主页&quot;&gt;&lt;/a&gt;创建仓库，生成默认主页&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;登录&lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;网站，（若没有账号，请自行注册）。&lt;/li&gt;
&lt;li&gt;创建新仓库：点击&lt;strong&gt;New respository&lt;/strong&gt;，进入相应页面，填写仓库的信息，&lt;strong&gt;仓库的名字必须是username/username.github.io&lt;/strong&gt;（即在&lt;em&gt;responsitory&lt;br&gt;name&lt;/em&gt;输入框中填写&lt;em&gt;username.github.io&lt;/em&gt;）,然后自行填写其他信息，点击&lt;em&gt;Create responsitory&lt;/em&gt;按钮即完成了新仓库的创建。&lt;/li&gt;
&lt;li&gt;生成个人主页：进入刚刚创建的仓库主页，点击-&amp;gt;setting-》Options-&amp;gt;Github Pages: Launch automatic page generator-》填写个人主页信息-》Continue to Layouts”-&amp;gt;选择一个自己喜欢的主题-》Publish,然后就可以通过&lt;em&gt;username.github.io&lt;/em&gt;访问你的主页了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;绑定其他域名（可选）&quot;&gt;&lt;a href=&quot;#绑定其他域名（可选）&quot; class=&quot;headerlink&quot; title=&quot;绑定其他域名（可选）&quot;&gt;&lt;/a&gt;绑定其他域名（可选）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果其他域名访问个人主页，请进行下面的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;购买个人域名（我个人从新网购买的域名）&lt;/li&gt;
&lt;li&gt;注册&lt;a href=&quot;https://www.dnspod.cn/Login&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DNSPod&lt;/a&gt;，点击域名解析-》添加记录，如下图所示 &lt;img src=&quot;./屏幕快照 2016-03-21 下午9.09.57.png&quot; alt=&quot;Alt text&quot;&gt; &lt;/li&gt;
&lt;li&gt;到域名购买网站，修改dns解析服务器地址为：&lt;strong&gt;f1g1ns1.dnspod.net&lt;/strong&gt; 和 &lt;strong&gt;f1g1ns2.dnspod.net&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;将域名与个人主页绑定：到个人主页，再根目录下新建文件CNAME,在文件中添加你的域名（不要带http和www），等1-3天后，即可通过此域名访问自己的个人主页.&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每一个github账号都可以创建一个用来存放个人主页，&lt;strong&gt;仓库的名字必须是username/username.github.io&lt;/strong&gt;，创建完成之后就可以使用&lt;strong&gt;username.github.io&lt;/stron
    
    </summary>
    
    
      <category term="github" scheme="http://clfaa.com/tags/github/"/>
    
  </entry>
  
</feed>
