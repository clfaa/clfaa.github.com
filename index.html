<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>常飞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="常飞">
<meta property="og:url" content="http://clfaa.com/index.html">
<meta property="og:site_name" content="常飞">
<meta property="og:description" content="个人技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常飞">
<meta name="twitter:description" content="个人技术博客">
  
    <link rel="alternative" href="/atom.xml" title="常飞" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ChangFei</a></h1>
		</hgroup>

		
		<p class="header-subtitle">记录时间</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/clfaa" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://www.jianshu.com/users/91baaabe7f3d/latest_articles" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/AsyncTask/" style="font-size: 10px;">AsyncTask</a> <a href="/tags/Debug/" style="font-size: 10px;">Debug</a> <a href="/tags/Executor/" style="font-size: 10px;">Executor</a> <a href="/tags/Keystore/" style="font-size: 10px;">Keystore</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/网络编程/" style="font-size: 10px;">网络编程</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">约吗？不约！？不约不告诉你~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ChangFei</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">ChangFei</h1>
			</hgroup>
			
			<p class="header-subtitle">记录时间</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/clfaa" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://www.jianshu.com/users/91baaabe7f3d/latest_articles" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Android-concurrent（一）——-Executor接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/04/Android-concurrent（一）——-Executor接口/" class="article-date">
  	<time datetime="2016-04-03T18:30:45.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/Android-concurrent（一）——-Executor接口/">Android concurrent（一）—— Executor接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="设计理念——为何而存在"><a href="#设计理念——为何而存在" class="headerlink" title="设计理念——为何而存在"></a>设计理念——为何而存在</h4><p>先来一发源码。</p>
<pre><code>public interface Executor {
    void execute(Runnable command);
}
</code></pre><p>就是这么短。那么这么短的一个接口存在的意义是什么呢？<br>下面就来分析一下。<br>当我们想创建并执行一个线程的时候，通常是这样的。</p>
<pre><code>new Thread(new(RunnableTask())).start()
</code></pre><p>是不是短！平！快！。这样不是很好吗？但是使用这种方式，我们无法控制程序中线程的数量，创建过多的线程会带来性能问题。我们需要一种方式控制线程的数量，有时我们还希望控制各个任务之间调度关系。Executor接口正式为解决这个问题而来。</p>
<blockquote>
<p>Executor接口官方介绍：An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc.  An Executor is normally used instead of explicitly creating threads. </p>
</blockquote>
<p>意思：Executor是用来提交Runnable的。它可以将Runnable的递交、使用的细节、调度与执行解耦。用来代替直接创建Thread的方式。</p>
<p>不容易理解？莫关系！下面通过一个实际应用来解释这段话。</p>
<p>比如，你想保证任务的顺序执行（每个时刻只有一个Runnable在执行，只有上一个Runnable执行完毕之后才会执行下一个Runnable）并且为每一个Runnable创建一个新的Thread。我们可以这样做:</p>
<pre><code>  //SerialExecutor提供调度功能，将用户提交的Runnable保存到一个队列里面，然后顺序执行
  class SerialExecutor implements Executor {
    //队列，用来存放提交进来的Runnable
    final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();
    //提交进来的Runnable实际执行的位置。
    final Executor executor;
    //当前正在执行的Runnable
    Runnable active;
    SerialExecutor(Executor executor) {
      this.executor = executor;
    }
    public synchronized void execute(final Runnable r) {
      //将Runnable包装，并添加到队里中。
      tasks.offer(new Runnable() {
        public void run() {
          try {
            r.run();
          } finally {
            //执行完毕后，会自动调用队里中的下一个Runnable
            scheduleNext();
          }
        }
      });
      if (active == null) {
        //首次调度
        scheduleNext();
      }
    }
    protected synchronized void scheduleNext() {
      if ((active = tasks.poll()) != null) {
        executor.execute(active);
      }
    }
  }}

//ThreadPerTaskExecutor是Runnable的实际执行的地方。为每一个Runnable创建一个Thread。
class ThreadPerTaskExecutor implements Executor {
 public void execute(Runnable r) {
     new Thread(r).start();
 }
}}

//执行：只有任务1执行完毕后才会执行任务2
Executor executor = new SerialExecutor(new ThreadPerTaskExecutor());
executor.execute(new Runnable(){
    public void run() {
         //任务1...     
    }
});
executor.execute(new Runnable(){
    public void run() {
         //任务2...     
    }
});
</code></pre><p>在这个例子中，SerialExecutor用于Runnable的调度，它将Runnable进行简单的包装，并保存到队里中。经过包装后，不仅会执行原始提交Runnable的代码，并且会执行结束后调用队列中的下一个Runnable。就这样,SerialExecutor实现了Runnable的顺序执行。而ThreadPerTaskExecutor类则是用来控制Runnable执行细节的地方，在这里，我们简单的为每个Runnable创建了新的Thread，在实际应用中，你可以使用线程池来复用Thread。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Executor被创造的原因：将任务的执行、任务的调度、任务的执行细节进行解耦。</p>
<ol>
<li>任务是如何调度的，你是想一个个的顺序执行，还是想多个任务一起并发并能自由的控制并发数量上线，都可以通过自己实现Executor接口进行定制。你只需要将任务通过Executor#execute(Runnable)方法提交进来就可以了，具体的调度方案，Runnable不需要关注。这样就实现了任务执行和调度的解耦。</li>
<li>对于任务的执行细节，你是想为每个任务都创建新的线程，还是想复用已有的线程，也可以通过实现Executor接口进行定制。同样，你只需要将任务通过Executor#execute(Runnable)方法提交进来就可以了，具体的执行细节，Runnable不需要关注。这样就实现了任务执行和执行细节的解耦。</li>
</ol>
<h4 id="设计模式的使用：中介者模式"><a href="#设计模式的使用：中介者模式" class="headerlink" title="设计模式的使用：中介者模式"></a>设计模式的使用：中介者模式</h4><p>在这里，使用了设计模式中的<strong>中介者模式</strong>，下面是中介者模式的定义和UML类图。</p>
<blockquote>
<p>中介者模式（Mediator Pattern）：定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互。</p>
<ol>
<li>抽象中介者（Mediator）角色：抽象中介者角色定义统一的接口用于各同事角色之间的通信。</li>
<li>具体中介者（Concrete Mediator）角色：具体中介者角色通过协调各同事角色实现协作行为。为此它要知道并引用各个同事角色。</li>
<li>同事（Colleague）角色：每一个同事角色都知道对应的具体中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。——《设计模式》</li>
</ol>
</blockquote>
<p>UML类图：</p>
<p><img src="/images/Mediator_Pattern.jpg" alt="Mediator_Pattern.jpg"></p>
<p>其中Executor就是一个抽象中介者角色，Executor的具体实现就是一个具体中介者角色，每个Runnable就相当于同事角色，Executor的execute(Runnable…)方法即是各个Runnable之间通信的接口，每个Runnable都被提交到Executor的具体实现类中，由Executor的具体实现类来协调各Runnable之间的实现协作行为。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Executor/">Executor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrent/">concurrent</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-网络编程之AsyncTask使用总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/25/网络编程之AsyncTask使用总结/" class="article-date">
  	<time datetime="2016-03-25T14:18:06.000Z" itemprop="datePublished">2016-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/25/网络编程之AsyncTask使用总结/">网络编程之AsyncTask使用总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="官方概述"><a href="#官方概述" class="headerlink" title="官方概述"></a>官方概述</h3><blockquote>
<p>AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.</p>
<p>AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask.</p>
<p>An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.</p>
</blockquote>
<p>翻译：<em>AsyncTask</em>可以恰当方便的操作UI线程。它可以执行后台任务，并把任务结果发布到UI线程，而且不需要手动的操作<em>thread</em>和<em>handler</em>。<br>AsyncTask并不是一个通常的线程框架，而是为Thread和Handler设计的帮助类。AsyncTask最适合用于耗时较短（最多几秒钟）的操作。如果需要在线程中执行长时间的操作，强烈推荐使用<em>java.util.concurrent</em>包提供的API,比如<em>Executor</em>,<em>TreadPoolExecutor</em>和<em>FutureTask</em>。<br>一个<em>AsyncTask</em>可以把操作的执行过程放到子线程中执行，把执行结果发布到UI线程。定义一个<em>AsyncTask</em>需要指定<em>Params</em>,<em>Progress</em>,<em>Result</em>三个泛型的类型，在执行过程中将调用<em>onPreExecute</em>,<em>doInBackground</em>, <em>onProgressUpdate</em> 和 <em>onPostExecute</em>四个方法。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>AsyncTask为抽象类,使用前必须先定义一个它的子类，实现<em>doInBackground()</em>方法，为Params,Progress,Result指定确切的参数。</p>
<h5 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h5><table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Params</td>
<td style="text-align:left">任务所需参数的类型，变长参数；在调用任务执行方法execute()时，作为execute的参数使用。若不使用，指定为Void</td>
</tr>
<tr>
<td>Progress</td>
<td style="text-align:left">说明任务执行的进度的类型，如Integer等;若不使用，指定为Void</td>
</tr>
<tr>
<td>Result</td>
<td style="text-align:left">任务完成后返回的结果的类型,若不使用，指定为Void</td>
</tr>
</tbody>
</table>
<h5 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h5><table>
<thead>
<tr>
<th>顺序</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">运行位置</th>
<th style="text-align:center">必须实现</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.Task执行前</td>
<td style="text-align:left">onPreExecute()</td>
<td style="text-align:left">UI Thread</td>
<td style="text-align:center">否</td>
<td>在Task执行前调用（即，doInBackground()法前），可用于做一些任务执行前的操作，如显示一个ProgressDialog说明进度</td>
</tr>
<tr>
<td>2.Task执行中</td>
<td style="text-align:left">doInBackground(Params…)</td>
<td style="text-align:left">background Thread</td>
<td style="text-align:center">是</td>
<td>用于执行Task,在此方法中，可以调用publishProgress(Progress…) 发布Task实时进度信息，在onProgressUpdate(Progress…)接收到发布的信息</td>
</tr>
<tr>
<td>3.Task执行中</td>
<td style="text-align:left">onProgressUpdate(Progress…)</td>
<td style="text-align:left">UI Thread</td>
<td style="text-align:center">否</td>
<td>接收publishProgress(Progress…)发布的Task进度信息，可以在这里更新显示进度的界面，</td>
</tr>
<tr>
<td>4.Task执行完成后</td>
<td style="text-align:left">onPostExecute(Result)</td>
<td style="text-align:left">UI Thread</td>
<td style="text-align:center">否</td>
<td>用于接收Task执行的结果，在UI thread中执行</td>
</tr>
</tbody>
</table>
<h5 id="官方提供的示例"><a href="#官方提供的示例" class="headerlink" title="官方提供的示例"></a>官方提供的示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个AysncTask类的子类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFilesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(URL... urls)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = urls.length;</span><br><span class="line">         <span class="keyword">long</span> totalSize = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">             totalSize += Downloader.downloadFile(urls[i]);</span><br><span class="line">             publishProgress((<span class="keyword">int</span>) ((i / (<span class="keyword">float</span>) count) * <span class="number">100</span>));</span><br><span class="line">             <span class="comment">// Escape early if cancel() is called</span></span><br><span class="line">             <span class="keyword">if</span> (isCancelled()) <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> totalSize;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>&#123;</span><br><span class="line">         setProgressPercent(progress[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span> </span>&#123;</span><br><span class="line">         showDialog(<span class="string">"Downloaded "</span> + result + <span class="string">" bytes"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line"><span class="keyword">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，定义了一个AsyncTask的子类DownloadFilesTask，其中URL对应Params,Integer表示进度Progress,Long为执行结果Result的类型。<br>doInBackground()方法体的代码将在子线程中执行。<br>publishProgress()方法用来发布任务执行进度情况，此方法被调用后，会唤起在UI线程中执行的onProgresssUpdate()方法，并接收publishProgress()发布的信息，我们可以根据这些信息更新我们的view等。<br>当后台任务执行完成后，onPostExecute()方法会被调用，此方法也是在UI线程中执行。</p>
<h5 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h5><ol>
<li>AsyncTask类必须加载在UI thread。（Android系统会自动完成，不需要管）</li>
<li>AsyncTask类的必须在UI thread中实例化。（因为AsyncTask中的Handler必须属于UI thread,AsyncTask才能和UI thread中执行）</li>
<li>execute(Params…) 必须在UI thread中被调用。</li>
<li>不要手动调用 onPreExecute(), onPostExecute(Result), doInBackground(Params…), onProgressUpdate(Progress…) 方法，这些方法的调用由AsyncTask自定完成</li>
<li>一个AsyncTask的实例只能执行一次，即，execute(Params…)方法只能调用一次</li>
</ol>
<h3 id="取消Task"><a href="#取消Task" class="headerlink" title="取消Task"></a>取消Task</h3><p>官方说明:</p>
<blockquote>
<p>A task can be cancelled at any time by invoking <strong>cancel(boolean)</strong>. Invoking this method will cause subsequent calls to <strong>isCancelled()</strong> to return true. After invoking this method, <strong>onCancelled(Object)</strong>, instead of <strong>onPostExecute(Object) </strong>will be invoked after <strong>doInBackground(Object[])</strong> returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of <strong>isCancelled()</strong> periodically from <strong>doInBackground(Object[])</strong>， if possible (inside a loop for instance.)</p>
</blockquote>
<p>翻译：你可以在任何时候通过调用<strong>cancel(boolean)</strong>取消Task，<strong>cancel(boolean)</strong>方法被调用后，调用<strong>isCancelled()</strong>方法将返回<strong>True</strong>,并且在<strong>doInBackground(Object[])</strong>返回后，不在调用<strong>onPostExecute(Object) </strong>，而是调用 <strong>onCancelled(Object)</strong>。为了保证Task尽可能快的被取消掉，你应该在<strong>doInBackground(Object[])</strong>方法中不停的查询 <strong>isCancelled()</strong> 的返回值，最好在方法中实现一个循环。</p>
<p>我们来看一下<strong>cancel(boolean)</strong>的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mCancelled = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">   mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> mFuture.cancel(mayInterruptIfRunning);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>cancle(boolean)</strong>只是将mCancelled的值置为true，而任是真正被取消的操作，要在doInBackground(Params)方法中通过查询mCancelled的值为true时才进行取消。</p>
<p>官方指出最好在<strong>doInBackground(Object[])</strong>中实现一个循环，用来保证尽快收到任务取消的信息。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (isCancelled())&#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>但是有时候，我们无法使用循环，比如读取文件、请求网络等。如果你调用了<strong>cancel(false)</strong>，任务会继续执行，直到任务完成，但<strong>onPostExecute()</strong>将不被会被调用，而是调用<strong>onCancel()</strong>。但我们的初衷是想让任务马上停止，而不是继续执行到完成，所以我们的程序做了无用功。如果使用cancel(true) 方法，即，参数mayInterruptIfRunning被置为true,那将提前中断我们的任务，但是如果我们的方法是不可中断的，例如BitmapFactory.decodeStream()方法，那么任务将继续执行。你可以过早的关闭这个流（stream）并捕获它抛出的异常，但这并不是通过调用<strong>cancel(true)</strong>完成的，因此<strong>cancel(true)</strong>就变的没有意义了。</p>
<h3 id="执行顺序：多个AsyncTask实例之间的执行顺序"><a href="#执行顺序：多个AsyncTask实例之间的执行顺序" class="headerlink" title="执行顺序：多个AsyncTask实例之间的执行顺序"></a>执行顺序：多个AsyncTask实例之间的执行顺序</h3><p>在Android 1.6之前AsyncTask是顺序执行的，在一个App中，只有前一个Task执行完成后, 下一个AsyncTask才能执行。<br>在Android 1.6-Android2.3中，由一个线程池来管理多个线程，同一时刻，可以有多个Task在执行。<br>从Android3.0开始，Google为了避免并行执行给多个应用带来的错误，有改为了顺序执行。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>执行顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>Android 1.6之前</td>
<td>顺序执行：</td>
</tr>
<tr>
<td>Android 1.6-Android2.3</td>
<td>并行</td>
</tr>
<tr>
<td>Android 3.0-至今</td>
<td>顺序执行</td>
</tr>
</tbody>
</table>
<p>当然我们可以通过调用 executeOnExecutor(java.util.concurrent.Executor, Params…）而非execute(Params..)方法来完成并行执行。<br>比如:</p>
<pre><code>aAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
</code></pre><h3 id="可能发生的内存泄露-Memory-leaks"><a href="#可能发生的内存泄露-Memory-leaks" class="headerlink" title="可能发生的内存泄露(Memory leaks)"></a>可能发生的内存泄露(Memory leaks)</h3><blockquote>
<p><strong>我们可能有这样的错觉：当Activity被销毁时，其创建的AsyncTask也同样会被销毁——其实，并不然！</strong></p>
</blockquote>
<p>当Activity销毁后，AsyncTask继续执行直到完成。如果你在Activity#onDestroy()中调用了 cancel(boolean)方法，它会继续执行onCancelled(Result result)方法，如果你没有调用 cancel(boolean)方法，它会执行onPostExecute(Result) 方法。</p>
<p>假如在Activity被销毁前，我们没有调用AsyncTask#cancel(boolean)方法。这可能引起内存泄露，导致程序崩溃。比如你在onPostExecute(Result) 中对Activity的View进行操作，但是这些View已经随着Activity的销毁不再存在。所以，我们要确保在Activity销毁前，取消掉Task。</p>
<p>因为异步任务有方法在background Thread 中执行（doInBackground()），并且也有方法在UI线程中执行（比如，onPostExecute()）；在Task运行阶段，它将持有Activity的引用。但是如果Activity已经被销毁，它仍然持有这个的内存的引用。如何在后续的操作中，使用这个已经销毁的Activity的引用，将直接导致程序崩溃。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AsyncTask/">AsyncTask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-自定义keystore" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/21/自定义keystore/" class="article-date">
  	<time datetime="2016-03-21T14:50:57.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/自定义keystore/">自定义Android debug keystore</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么替换"><a href="#为什么替换" class="headerlink" title="为什么替换"></a>为什么替换</h2><p>Android开发中，在使用第三方的sdk（如，百度地图，微信分享，友盟统计等）提供的功能时通常都要事先申请密钥，在申请密钥时需要填写keystore的数字签名（SHA1）。这样，只有使用此keystore打包生成的apk才能正常的调用这些第三方提供的功能。如果你不想在每次修改相关代码后，都要执行繁琐的验证打包安装等流程，才能测试相应得功能的话，就将此keystore替换默认keystore吧。如果你不想你团队的每一个人都要申请一个自己密钥进行调试的话，就把你的keystore分发给他们，让他们替换了吧。</p>
<h2 id="修改keystore信息"><a href="#修改keystore信息" class="headerlink" title="修改keystore信息"></a>修改keystore信息</h2><blockquote>
<p>想要替换默认的keystore，那么你的keystore的密码、别名等信息必须和默认debug.keystore的一样，默认debug.keystore的信息如下：<br>Keystore name: “debug.keystore”<br>Keystore password: “android”<br>Key alias: “androiddebugkey”<br>Key password: “android”<br>CN: “CN=Android Debug,O=Android,C=US”</p>
</blockquote>
<ol>
<li>重命名.keystore文件名：将自己的.keystore修改名称修改为debug.keystore（可选，只是在输入下面的命令是，将debug.keystore更换为你的keystore文件名）</li>
<li>修改keystore密码为“android”：键入命令<br><code>keytool -storepasswd -new android -keystore debug.keystore</code><br>按提示输入原密码，修改密码完成</li>
<li>修改别名为androiddebugkey：<br><code>keytool -changealias -keystore debug.keystore -alias 原别名 -destalias androiddebugkey</code>,<br>按提示输入keystore密码、alias 原密码、新密码、再次输入新密码</li>
</ol>
<h2 id="替换IDE的keystore"><a href="#替换IDE的keystore" class="headerlink" title="替换IDE的keystore"></a>替换IDE的keystore</h2><h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><p>依次选择：Window-&gt;Preferences-&gt;Android-&gt;Build-&gt;Custom debug keystore，选择你刚刚修改完成的keystore文件。</p>
<h3 id="Intellij-Idea"><a href="#Intellij-Idea" class="headerlink" title="Intellij Idea"></a>Intellij Idea</h3><p>依次选择：Project structure -&gt; Facets -&gt;Packaging -&gt; custom debug keystore，选择你刚刚修改完成的keystore文件。</p>
<h3 id="Android-Studio（不需要进行上面的步骤）"><a href="#Android-Studio（不需要进行上面的步骤）" class="headerlink" title="Android Studio（不需要进行上面的步骤）"></a>Android Studio（不需要进行上面的步骤）</h3><p>在项目的build.gradle的中引入如下代码：</p>
<pre><code>android {
         //配置keystore签名
        signingConfigs {
            release {
                storeFile file(&quot;xxxxxxxxStore&quot;)
                storePassword &quot;xxxxxxxx&quot;
                keyAlias &quot;timehut team&quot;
                keyPassword &quot;xxxxxxxx&quot;
            }
        }
        buildTypes {
            debug {
                signingConfig signingConfigs.release
            }
            release {
                signingConfig signingConfigs.release
            }
        }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debug/">Debug</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Keystore/">Keystore</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-在github上创建个人主页" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/21/在github上创建个人主页/" class="article-date">
  	<time datetime="2016-03-21T13:25:42.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/在github上创建个人主页/">在github上创建个人主页</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>每一个github账号都可以创建一个用来存放个人主页，<strong>仓库的名字必须是username/username.github.io</strong>，创建完成之后就可以使用<strong>username.github.io</strong>来访问自己的个人主页了。</p>
</blockquote>
<h2 id="创建仓库，生成默认主页"><a href="#创建仓库，生成默认主页" class="headerlink" title="创建仓库，生成默认主页"></a>创建仓库，生成默认主页</h2><ol>
<li>登录<a href="https://github.com" target="_blank" rel="external">github</a>网站，（若没有账号，请自行注册）。</li>
<li>创建新仓库：点击<strong>New respository</strong>，进入相应页面，填写仓库的信息，<strong>仓库的名字必须是username/username.github.io</strong>（即在<em>responsitory<br>name</em>输入框中填写<em>username.github.io</em>）,然后自行填写其他信息，点击<em>Create responsitory</em>按钮即完成了新仓库的创建。</li>
<li>生成个人主页：进入刚刚创建的仓库主页，点击-&gt;setting-》Options-&gt;Github Pages: Launch automatic page generator-》填写个人主页信息-》Continue to Layouts”-&gt;选择一个自己喜欢的主题-》Publish,然后就可以通过<em>username.github.io</em>访问你的主页了。</li>
</ol>
<h2 id="绑定其他域名（可选）"><a href="#绑定其他域名（可选）" class="headerlink" title="绑定其他域名（可选）"></a>绑定其他域名（可选）</h2><blockquote>
<p>如果其他域名访问个人主页，请进行下面的操作。</p>
</blockquote>
<ol>
<li>购买个人域名（我个人从新网购买的域名）</li>
<li>注册<a href="https://www.dnspod.cn/Login" target="_blank" rel="external">DNSPod</a>，点击域名解析-》添加记录，如下图所示 <img src="./屏幕快照 2016-03-21 下午9.09.57.png" alt="Alt text"> </li>
<li>到域名购买网站，修改dns解析服务器地址为：<strong>f1g1ns1.dnspod.net</strong> 和 <strong>f1g1ns2.dnspod.net</strong> </li>
<li>将域名与个人主页绑定：到个人主页，再根目录下新建文件CNAME,在文件中添加你的域名（不要带http和www），等1-3天后，即可通过此域名访问自己的个人主页.</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 ChangFei
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>